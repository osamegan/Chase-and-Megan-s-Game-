<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Chess.io</title>
</head>
<body onload = "setBoard()">

    <style>
    
    .start {
        background-color: green;
        margin-left: 48%;
        margin-bottom: 10px;
        padding: 5px;
        color: white;
        width:fit-content;
    }
    .chessboard {
        width: 600px;
        height: 600px;
        margin: auto;
        border-collapse: collapse;
        border-spacing: 0px;
    }
 /* chessboard coordanites */
    .whiteTile {
        border: 1px solid black;
        width: 30px;
        height: 30px;
        background-color: white;
        margin: 0px;
        border-collapse: collapse;
    }
/* White tile coordinates */
    .blackTile {
        border: 1px solid black;
        width: 30px;
        height: 30px;
        background-color: black;
        margin: 0px;
        border-collapse: collapse;
    }
/* Black tile coordinates */
    .redTile {
        border: 1px solid black;
        width: 30px;
        height: 30px;
        background-color: rgb(253, 103, 103);
        margin: 0px;
        border-collapse: collapse;
    }
/* red tile coordanites and coloring */
    .blueTile {
        border: 1px solid black;
        width: 30px;
        height: 30px;
        background-color: rgb(93, 93, 255);
        margin: 0px;
        border-collapse: collapse;
    }
/*  blue tile coordanites and coloring */
    .pinkTile {
        border: 1px solid black;
        width: 30px;
        height: 30px;
        background-color: rgb(255, 224, 229);
        margin: 0px;
        border-collapse: collapse;
    }
/*  pink tile coordanites and coloring */
    .orangeTile {
        border: 1px solid black;
        width: 30px;
        height: 30px;
        background-color: rgb(255, 190, 70);
        margin: 0px;
        border-collapse: collapse;
    }
/*  orange tile coordanites and coloring */
    .packed {
        padding: 0;
        margin: 0;
        border-collapse: collapse;
        width: 30px;
        height: 30px;
        display: inline-block;
    }

    div {
        margin: 0% 46.25%;
        width: 150px;
        text-align: center;
        position: relative;
    }

    div:hover {
        color: blueviolet;
    }

    div:hover .tooltip {
        visibility: visible;
        opacity: 1;
    }

    .tooltip {
        position: absolute;
        color: black;
        background-color: rgba(255, 251, 0, 0.5);
        font-size: 12px;
        padding: 5px 0px;
        z-index: 1;
        visibility: hidden;
        font-family: Georgia, 'Times New Roman', Times, serif;
        width: 200px;
        bottom: 200%;
        left: -20%;
        opacity: 0;
        transition: opacity 0.7s;
    }

    .moveLog {
        visibility: hidden;
        margin: 0px 0px 0px 10px;
        background-color: lightgray;
        font-family: Cambria, Cochin, Georgia, Times, 'Times New Roman', serif;
        position: fixed;
        width: 200px;
        text-align: center;
    }

    </style>
    <pre class = 'moveLog' id = 'movementLog'></pre>
    <h1 style="text-align: center;">Chess.io Photoshoot Playground</h1>

    <img id = "redRook" src="images/Red-Ghost-Left.png" alt="" height = 0px width = 0px>
    <img id = "blueRook" src="images/Blue-Ghost-Left.png" alt="" height = 0px width = 0px>
    <img id = "pinkRook" src="images/Pink-Ghost-Left.png" alt="" height = 0px width = 0px>
    <img id = "orangeRook" src="images/Orange-Ghost-Left.png" alt="" height = 0px width = 0px>
    <img id = "redKnight" src="images/Red-Pacman.png" alt="" height = 0px width = 0px>
    <img id = "blueKnight" src="images/Blue-Pacman.png" alt="" height = 0px width = 0px>
    <img id = "pinkKnight" src="images/Pink-Pacman.png" alt="" height = 0px width = 0px>
    <img id = "orangeKnight" src="images/Orange-Pacman.png" alt="" height = 0px width = 0px>
    <img id = "redBishop" src="images/Scared-Ghost-Red.png" alt="" height = 0px width = 0px>
    <img id = "blueBishop" src="images/Scared-Ghost-Blue.png" alt="" height = 0px width = 0px>
    <img id = "pinkBishop" src="images/Scared-Ghost-Pink.png" alt="" height = 0px width = 0px>
    <img id = "orangeBishop" src="images/Scared-Ghost-Orange.png" alt="" height = 0px width = 0px>
    <img id = "redKing" src="images/Red-King.png" alt="" height = 0px width = 0px>
    <img id = "blueKing" src="images/Blue-King.png" alt="" height = 0px width = 0px>
    <img id = "pinkKing" src="images/Pink-King.png" alt="" height = 0px width = 0px>
    <img id = "orangeKing" src="images/Orange-King.png" alt="" height = 0px width = 0px>
    <img id = "questionMark" src = "images/Question Mark.png" alt="" height = 0px width = 0px>
<!-- names pictures -->

    <div id = 'turns' style = "color: red">Red Player's Turn!</div>
    <div onclick = makeVisible()>
        <span id = 'turnCount'>See Move Log</span>
        <span id = 'tooltip' class = 'tooltip'>This Tooltip Is Still Here Just For Fun!</span>
    </div>
    <select id = "color" style = "margin-left: 43%">
        <option value="red">Red</option>
        <option value="blue">Blue</option>
        <option value="pink">Pink</option>
        <option value="orange">Orange</option>
        <option value="black">Black</option>
        <option value="white">White</option>
    </select>

    <select id="piece">
        <option value="Rook">Rook</option>
        <option value="Bishop">Bishop</option>
        <option value="Knight">Knight</option>
        <option value="King">King</option>
        <option value="?">?</option>
        <option value="emptySquare">Empty Square</option>
    </select>

    <select id="y-value">
        <option value="A">A</option>
        <option value="B">B</option>
        <option value="C">C</option>
        <option value="D">D</option>
        <option value="E">E</option>
        <option value="F">F</option>
        <option value="G">G</option>
        <option value="H">H</option>
        <option value="I">I</option>
        <option value="J">J</option>
        <option value="K">K</option>
        <option value="L">L</option>
        <option value="M">M</option>
        <option value="N">N</option>
        <option value="O">O</option>
        <option value="P">P</option>
        <option value="Q">Q</option>
        <option value="R">R</option>
        <option value="S">S</option>
        <option value="T">T</option>
    </select>

    <select id="x-value">
        <option value="1">1</option>
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5">5</option>
        <option value="6">6</option>
        <option value="7">7</option>
        <option value="8">8</option>
        <option value="9">9</option>
        <option value="10">10</option>
        <option value="11">11</option>
        <option value="12">12</option>
        <option value="13">13</option>
        <option value="14">14</option>
        <option value="15">15</option>
        <option value="16">16</option>
        <option value="17">17</option>
        <option value="18">18</option>
        <option value="19">19</option>
        <option value="20">20</option>
    </select>

    <table id = "chessboard"></table>

    <script>
        
        let board = document.getElementById("chessboard");
        board.setAttribute("class", "chessboard");
        let letters = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T'];
        let chessPieces = [];
        let selected = {};
        let crossedTiles = [];
        let innerArea = [];
        let movements = [];
        let log = '';
        crossedTiles.fill = function(tile, color) {
            let allIds = crossedTiles.map(getId);
            let theHalf = 0;
            let ids = null;
            allIds.indexOf(tile.id) > 2 ? theHalf = 2 : theHalf = 1;
            if (theHalf === 1) {
                ids = allIds.slice(1, 3)
                crossedTiles.unfill(document.getElementById(allIds[3]));
            } else {
                ids = allIds.slice(3, 6);
                ids.push(allIds[0]);
                crossedTiles.unfill(document.getElementById(allIds[1]));
            }
            ids.forEach((square, index) => {
                let ctx = document.getElementById(square).getContext("2d");
                let questionMark = document.getElementById('questionMark');
                if (((index != 3 && theHalf === 1) || (theHalf === 2 && index != 0)) && !document.getElementById(square).piece) {
                    ctx.drawImage(questionMark,  7.5, 3.75, 275, 134.5);
                }
            })
            fillTerritory({[color]: ids});
        }
        // assigns each tile a letter and number
        crossedTiles.unfill = function(tile) {
            let theHalf = 0;
            let ids = null;
            crossedTiles.indexOf(tile) > 2 ? theHalf = 2 : theHalf = 1;
            if (theHalf === 1) {
                ids = crossedTiles.slice(0, 3);
            } else {
                ids = crossedTiles.slice(4, 6);
            }
            ids.forEach(originalColor);
        }
        crossedTiles.set = (tile) => {
            for (let square of crossedTiles) {
                square.removeAttribute("onmouseover");
                square.removeAttribute("onclick");
                square.lastColor = square.className.slice(0, square.className.indexOf('T'));
                let ctx = square.getContext("2d");
                if (!square.piece || (square.piece && (square.piece.currentColor != square.piece.color && square.className === tile.className) && square.piece.color != tile.className.slice(0, tile.className.indexOf('T')))) {
                    ctx.clearRect(0, 0, 300, 150);
                }
                if (square.piece && (square.piece.currentColor != square.piece.color && square.className === tile.className) && square.piece.color != tile.className.slice(0, tile.className.indexOf('T'))) {
                    delete square.piece;
                }
            }
            if (turnToggle === "off") {
                turnProgress('knight', tile);
            }
            let knightSquare = crossedTiles[3];
            empty(crossedTiles);
            findEnclosedTiles(knightSquare);
            crossedTiles.forEach((square) => {
                square.setAttribute("class", `${tile.className}`);
                square.lastColor = tile.className.slice(0, tile.className.indexOf('T'));
            });
            empty(crossedTiles);
        }
        let turn = 1;
        let turnToggle = 'off';
        const moves = {
            rook: {
                vertical: true,
                horizontal: true,
                diagonal: false,
                knight: false,
                range: Infinity,                
                leavable: true,
            },

            bishop: {
                vertical: false,
                horizontal: false,
                diagonal: true,
                knight: false,
                range: Infinity,
                leavable: true,
            },

            knight: {
                vertical: false,
                horizontal: false,
                diagonal: false,
                knight: true,
                range: undefined,
                leavable: true,
            },

            king: {
                vertical: true,
                horizontal: true,
                diagonal: true,
                knight: false,
                range: 1,
                leavable: false,
            }
            //gives each piece their possible moves
        };

        function setBoard() {
            let start = document.createElement("BUTTON");
            start.setAttribute("class", "start");
            start.id = "start";
            start.innerHTML = "Place Piece";
            start.setAttribute("onclick", "placePiece(document.getElementById('color').value.concat(document.getElementById('piece').value), document.getElementById('y-value').value.concat(document.getElementById('x-value').value))");
            document.body.appendChild(start);
            createBoard();
            makePieces();
        }

        function placePiece(thePiece, destination) {
            let tile = document.getElementById(`${destination}`);
            let ctx = tile.getContext('2d');
            if (!thePiece.includes('emptySquare')) {
            let piece = chessPieces.find((piece) => {
                if (thePiece.includes('?')) {
                    return piece.id === 'questionMark1';
                }
                return piece.id === thePiece.concat('1');
            });
            ctx.drawImage(piece.image, 7.5, 3.75, 275, 134.5);
            tile.piece = piece;
            tile.lastColor = piece.color;
            piece.currentPos = destination;
            } else {
                ctx.clearRect(0, 0, 300, 150);
                delete tile.piece;
                tile.lastColor = document.getElementById('color').value;
            }
            tile.currentColor = tile.lastColor;
            tile.setAttribute('class', `${document.getElementById('color').value}Tile`);
        } 

// sets the board
        function createBoard() {
            let start = document.getElementById('start');
            let letterNum = 0;
            let number = 1;
            for (let columnLength = 0; columnLength < 20; columnLength ++) {
                let column = document.createElement("TR");
                column.setAttribute("class", "packed");
                for (let rowLength = 0; rowLength < 20; rowLength ++) {
                    let row = document.createElement("TD");
                    row.setAttribute("class", "packed");
                    let tile = document.createElement("CANVAS");
                    tile.id = `${letters[letterNum]}${number}`
                    tile.setAttribute("class", "packed");
                    tile.addEventListener("click", (e) => {
                        if (selected.piece && checkLegality(selected.piece, tile.id) === 'legal' && !(Array.from(document.getElementsByTagName("CANVAS")).some(function(tile) {
                            if (tile.onmouseover) {
                                return true;
                            }
                        })) && isTurnLegal(selected.piece.color) && selected.tile.id === selected.piece.currentPos) {
                            moveTo(selected.piece, tile.id);
                            if (!crossedTiles.some(function(tile) {
                                return tile.currentColor ? false : true;
                            })) {
                                crossedTiles.forEach(setLastColor);
                            }
                            selected.piece.type === 'knight' ? crossedTiles.slice(0, 4).forEach(setCurrentColor) : crossedTiles.forEach(setCurrentColor);
                            selected.tile.setAttribute("style", "border: 1px solid black");
                            let ctx = selected.tile.getContext("2d");
                            ctx.clearRect(0, 0, selected.tile.width, selected.tile.height);
                            if (selected.piece.type === 'knight' && crossedTiles.some((square) => {
                return square.className != tile.className;
            })) {
                                ctx.drawImage(questionMark,  7.5, 3.75, 275, 134.5);
                            }
                            delete selected.piece;
                            delete selected.tile.piece;
                            delete selected.tile;
                        } else if (!(Array.from(document.getElementsByTagName("CANVAS")).some(function(tile) {
                            if (tile.onmouseover) {
                                return true;
                            }
                        }))) {
                            empty(crossedTiles);
                            tile.setAttribute("style", "border: 1px blue");
                            selected.tile ? selected.tile.setAttribute("style", "border: 1px solid black") : selected.tile = tile;
                            selected.tile = tile;
                            tile.piece ? selected.piece = tile.piece : tile.piece = null;
                        }
                    });
                    if (columnLength  % 2 === 0) {
                        rowLength % 2 === 0 ? tile.setAttribute("class", "whiteTile") : tile.setAttribute("class", "blackTile");
                    } else {
                        rowLength % 2 != 0 ? tile.setAttribute("class", "whiteTile") : tile.setAttribute("class", "blackTile");
                    }
                    tile.lastColor = tile.className.slice(0, tile.className.indexOf('T'));
                    row.appendChild(tile);
                    column.appendChild(row);
                    letterNum ++;
                }
                board.appendChild(column);
                letterNum = 0;
                number ++;
            }
            document.body.appendChild(board);
        }


        function makePieces() {
            let colors = ['red', 'blue', 'pink', 'blue'];
            for (let color of colors) {
                createPiece('Rook', color, 1);
                createPiece('Rook', color, 2);
                createPiece('Bishop', color, 1);
                createPiece('Bishop', color, 2)
                createPiece('Knight', color, 1);
                createPiece('Knight', color, 2);
                createPiece('King', color, 1);
                createPiece('Mark', 'question', 1);
            }
        }

        function chooseColor() {
            let color1 = "red";
            let color2 = "blue";
            let color3 = "pink";
            let color4 = "orange";
            setPieces([color1, color2, color3, color4]);
        }
// names each color
        function setPieces(colors) {
            for (let color of colors) {
                createPiece('Rook', color, 1);
                createPiece('Rook', color, 2);
                createPiece('Bishop', color, 1);
                createPiece('Bishop', color, 2)
                createPiece('Knight', color, 1);
                createPiece('Knight', color, 2);
                createPiece('King', color, 1);
            }
            let positions = ["C1", "B3", "C2", "A3", "B2", "C3", "A1", "B18", "C20", "A18", "C19", "C18", "B19", "A20", "R1", "S3", "R2", "T3", "S2", "R3", "T1", "S18", "R20", "T18", "R19", "R18", "S19", "T20"];
            for (let pieces in chessPieces) {
                let position = positions[pieces];
                if (position) {
                    let tile = document.getElementById(position)
                    let ctx = tile.getContext("2d");
                    ctx.drawImage(chessPieces[pieces].image, 7.5, 3.75, 275, 134.5);
                    tile.setAttribute("class", `${chessPieces[pieces].color}Tile`);
                    tile.piece = chessPieces[pieces];
                    tile.lastColor = chessPieces[pieces].color;
                    chessPieces[pieces].currentPos = position;
                }
            }
        }
// gives the pieces' positions
        function createPiece(type, color, number) {
            let piece = {};
            piece.image = new Image();
            piece.image.src = document.getElementById(`${color}${type}`).src;
            piece.type = type.toLowerCase();
            piece.color = color;
            piece.id = `${color}${type}${number}`;
            piece.movability = moves[piece.type];
            chessPieces.push(piece);
        }
// creates the pieces
        function moveTo(piece, square) {
            let tile = document.getElementById(square);
            let ctx = tile.getContext("2d");
            ctx.drawImage(piece.image, 7.5, 3.75, 275, 134.5);
            tile.setAttribute("class", `${piece.color}Tile`);
            tile.lastColor = selected.piece.color;
            tile.piece = piece;
            piece.currentPos = square;
            if (piece.type != 'knight' || !crossedTiles.some((square) => {
                return square.className != tile.className;
            })) {
                crossedTiles.forEach(color);
                findEnclosedTiles(tile);
                crossedTiles.forEach(color);
                if (turnToggle === "off") {
                    turnProgress(piece, tile);
                }
        }
            if (piece.type === 'knight' && crossedTiles.some((square) => {
                return square.className != tile.className;
            })) {
                (crossedTiles.filter((tile, index) => {
                    return index < 4;
                })).forEach(color);
                userSelect();
            } else {
                empty(crossedTiles);
            }
        }
// makes the pieces move
        function checkLegality(piece, square) {
            let tile = document.getElementById(square);
            let startNumber = Number(piece.currentPos.slice(1, 3));
            let endNumber = Number(square.slice(1, 3));
            let moveType = null;
            let slope = (letters.indexOf(piece.currentPos[0]) + 1 - (letters.indexOf(square[0]) + 1)) / (startNumber - endNumber);
            let ranged = null;
            let distance = findDistance(startNumber, endNumber, letters.indexOf(piece.currentPos[0]) + 1, letters.indexOf(square[0]) + 1);
            Math.abs(letters.indexOf(piece.currentPos[0]) + 1 - (letters.indexOf(square[0]) + 1)) > 1 || Math.abs(startNumber - endNumber) > 1 ? ranged = true : ranged = false;
            if (piece.currentPos[0] === square[0]) {
                moveType = 'horizontal';
            } else if (startNumber === endNumber){
                moveType = 'vertical';
            } else if (Math.abs(slope) === 1) {
                moveType = 'diagonal';
            } else if (distance === Math.sqrt(5)) {
                moveType = 'knight';
            } else {
                moveType = 'invalid';
            }
            if (tile.piece || (piece.type === 'king' && (ranged === true || tile.className.slice(0, tile.className.indexOf('T')) != piece.color)) || !piece.movability[moveType]) {
                jurisdiction = 'illegal';
            } else {
                jurisdiction = 'legal';
                logCrossedTiles(moveType, piece.currentPos, square, slope);
                if (crossedTiles.some((tile) => {
                    return tile.piece ? true : false;
                }) && piece.type != 'knight') {
                    jurisdiction = 'illegal';
                }
            }
            return jurisdiction;
        }

// checks the legality of the moves

    function findDistance(x1, x2, y1, y2) {
        return Math.sqrt(Math.pow((x2-x1), 2) + Math.pow((y2-y1), 2));
    }
        function logCrossedTiles(moveType, start, end, slope) {
            let idLetter = start[0];
            let idNumber = Number(start.slice(1, 3));
            let endLetter = end[0];
            let endNumber = Number(end.slice(1, 3));
            let round = 0;
            for (let tile = document.getElementById(start); tile.id != end; tile = document.getElementById(`${idLetter}${idNumber}`)) {
                crossedTiles.push(tile);
                if (moveType === 'knight') {
                    round ++;
                    Math.abs(slope) > 1 ? round < 3 ? moveType = 'vertical' : moveType = 'horizontal' : round < 3 ? moveType = 'horizontal' : moveType = 'vertical';
                }
                moveType === 'horizontal' ? idLetter = idLetter : endLetter > idLetter ? idLetter = letters[letters.indexOf(idLetter) + 1] : idLetter = letters[letters.indexOf(idLetter) - 1];
                moveType === 'vertical' ? idNumber = idNumber : endNumber > idNumber ? idNumber ++ : idNumber --;
                round === 0 ? moveType = moveType : moveType = 'knight';
                if (round === 3) {
                    if (end === start) {
                        return;
                    }
                    end = start;
                    endLetter = end[0];
                    endNumber = Number(end.slice(1, 3));
                    round = 0;
                }
            }
            if (moveType != 'knight') {
                crossedTiles.shift();
            }
        }

        function fillTerritory(obj) {
            let colors = Object.keys(obj);
            for (let color of colors) {
                let ids = obj[color];
                for (let id of ids) {
                    let tile = document.getElementById(id);
                    tile.setAttribute('class', `${color}Tile`);
                    if (turn === 1 && crossedTiles.length != 6) {
                        tile.lastColor = color;
                    }
                }
            }
        }

        function userSelect() {
            for (let tile in crossedTiles) {
                if (Number(tile) < 6) {
                    crossedTiles[tile].setAttribute("onclick", "crossedTiles.set(this)");
                    if (Number(tile) < 3) {
                        crossedTiles[tile].setAttribute("onmouseover", "crossedTiles.fill(this, this.currentColor)");
                    } else {
                        crossedTiles[tile].setAttribute("onmouseover", "crossedTiles.fill(this, crossedTiles[0].currentColor)");
                    }
                }
            }
        }
// lets the player click on the tiles
        function empty(array) {
            while (array.length > 0) {
                array.shift();
            }
        }
// empties the array
        function color(tile) {
            tile.setAttribute("class", `${selected.piece.color}Tile`);
            if (selected.piece.type != 'knight' || !crossedTiles.some((square) => {
                return square.className != tile.className;
            }))  {
                tile.lastColor = selected.piece.color;
            } else {
                let questionMark = document.getElementById('questionMark');
                let ctx = tile.getContext("2d");
                if (crossedTiles.indexOf(tile) != 3 && !tile.piece) {
                    ctx.drawImage(questionMark,  7.5, 3.75, 275, 134.5);
                }
            }
        }
// colors the tile
        function originalColor(tile) {
            tile.setAttribute('class', `${tile.lastColor}Tile`);
            let ctx = tile.getContext("2d");
            if (!tile.piece) {
                ctx.clearRect(0, 0, 300, 150);
            }
        }
// gives the tile its original color
        function getId(canvas) {
            return canvas.id;
        }
// gets the canvas id
        function setCurrentColor(item) {
            item.currentColor = selected.piece.color;
        }
// gives the original color
        function setLastColor(item) {
            item.lastColor = item.currentColor;
        }
// sets the item's last color
        function isTurnLegal(color) {
            if (turnToggle != 'on') {
                return true; //THIS IS TEMPORARY!!!
            }
            let rightfulColor = null;
            turn % 4 === 2 ? rightfulColor = 'blue' : turn % 4 === 3 ? rightfulColor = 'pink' : turn % 4 === 0 ? rightfulColor = 'orange' : rightfulColor = 'red'; 
            if (rightfulColor === color) {
                return true;
            } else {
                return false;
            }
        }

        function findEnclosedTiles(tile) {
            empty(innerArea);
            let coloredTiles = Array.from(document.getElementsByClassName(`${tile.className}`)).map((tile) => {
                return tile.id;
            });
            let topmostTiles = ((((coloredTiles.sort()).reverse()).filter(noRepeatingNumbers)).map(backToElements)).sort(leftToRight);
            let bottommostTiles = (((coloredTiles.sort()).filter(noRepeatingNumbers)).map(backToElements)).sort(leftToRight);
            let rightmostTiles = (((coloredTiles.sort(function (a, b) {
                return Number(a.slice(1, 3)) - Number(b.slice(1, 3));
            })).filter(noRepeatingLetters)).map(backToElements)).sort(topToBottom);
            let leftmostTiles = (((coloredTiles.sort(function (a, b) {
                return Number(b.slice(1, 3)) - Number(a.slice(1, 3));
            })).filter(noRepeatingLetters)).map(backToElements)).sort(topToBottom);
            let nonpolygon = Array.from(document.getElementsByTagName('CANVAS')).filter((square) => {
                return square.className != tile.className
            });
            innerArea = nonpolygon.filter((square) => {
                if (topmostTiles.find((correspondingTile) => {
                    return Number(correspondingTile.id.slice(1, 3)) === Number(square.id.slice(1, 3)) || touches(square, null, 'aboveTile') ? true : false;
                }) && bottommostTiles.find((correspondingTile) => {
                    return Number(correspondingTile.id.slice(1, 3)) === Number(square.id.slice(1, 3)) || touches(square, null, 'belowTile') ? true : false;
                }) && leftmostTiles.find((correspondingTile) => {
                    return correspondingTile.id[0] === square.id[0] || touches(square, null, 'leftTile') ? true : false;
                }) && rightmostTiles.find((correspondingTile) => {
                    return correspondingTile.id[0] === square.id[0] || touches(square, null, 'rightTile') ? true : false;
                })) {
                    if ((letters.indexOf(square.id[0]) > letters.indexOf((topmostTiles.find((correspondingTile) => {
                        return Number(correspondingTile.id.slice(1, 3)) === Number(square.id.slice(1, 3));
                    })).id[0]) || touches(square, null, 'aboveTile') ? true : false) && (letters.indexOf(square.id[0]) < letters.indexOf((bottommostTiles.find((correspondingTile) => {
                        return Number(correspondingTile.id.slice(1, 3)) === Number(square.id.slice(1, 3));
                    })).id[0]) || touches(square, null, 'belowTile') ? true : false) && ((Number(square.id.slice(1, 3)) > Number((leftmostTiles.find((correspondingTile) => {
                        return correspondingTile.id[0] === square.id[0];
                    })).id.slice(1, 3))) || touches(square, null, 'leftTile') ? true : false) && (Number(square.id.slice(1, 3)) < Number((rightmostTiles.find((correspondingTile) => {
                        return correspondingTile.id[0] === square.id[0];
                    })).id.slice(1, 3)) || touches(square, null, 'rightTile') ? true : false)) {
                        return true;
                    } else {
                        return false;
                    }
                } else {
                    return false;
                }
            });
            let broken = false;
            if (innerArea.length > 0) {
                broken = true;
            }
            while (broken) {
                innerArea.sort(function (a, b) {
                    if (!touches(a, null, 1)) {
                        return touches(a, `${tile.className}`, 1, 'unclosed') ? -1 : 1;
                    } else {
                        return touches(a, null, 1, 3)? 1 : -1;
                    }
                });
                for (let square of innerArea) {
                    if ((!touches(square, null, 1) && touches(square, `${tile.className}`, 1, 'unclosed')) || (touches(square, null, 1) && !touches(square, null, 1, 3))){
                        innerArea.splice(innerArea.indexOf(square), 1);
                        break;
                    } else {
                        crossedTiles.unshift(square);
                        if (innerArea.indexOf(square) === innerArea.length - 1) {
                            broken = false;
                        }
                    }
                }
                if (innerArea.length === 0) {
                    broken = false;
                }
            }
            while (innerArea.some((square) => {
                return square.piece ? true : false;
            })) {
                let square = innerArea.find((square) => {
                    return square.piece ? true : false;
                });
                let ctx = square.getContext("2d");
                ctx.clearRect(0, 0, 300, 150);
                delete square.piece;
                /*checkLivingPieces();*/
            }
            if (innerArea.some((square) => {
                return touches(square, null, 1);
            })) {
                crossedTiles.forEach((square) => {
                square.setAttribute("class", `${tile.className}`);
                if (tile.piece.type != 'knight' || !crossedTiles.some((tile) => {
                    return square.className != tile.className;
                }))  {
                    tile.lastColor = tile.piece.color;
                    }
                });
                findEnclosedTiles(tile);
            }
        }

        function noRepeatingNumbers(tile, index, array) {
            return (array.slice(index + 1)).find((newTile) => {
                return Number(newTile.slice(1, 3)) === Number(tile.slice(1, 3));
            }) ? false : true;
        }

        function noRepeatingLetters(tile, index, array) {
            return (array.slice(index + 1)).find((newTile) => {
                return newTile[0] === tile[0];
            }) ? false : true;
        }

        function backToElements(tile) {
            return document.getElementById(tile);
        }

        function touches(tile, tileType, direction, enclosedness) {
            let tileLetter = letters[letters.indexOf(tile.id[0])];
            let tileNumber = Number(tile.id.slice(1, 3));
            let touchingTiles = {
                'aboveTile' : document.getElementById(`${letters[letters.indexOf(tileLetter) - 1]}${tileNumber}`), 
                'belowTile' : document.getElementById(`${letters[letters.indexOf(tileLetter) + 1]}${tileNumber}`),
                'leftTile' : document.getElementById(`${tileLetter}${tileNumber - 1}`),
                'rightTile' : document.getElementById(`${tileLetter}${tileNumber + 1}`)
            };
            let trueCount = 0;
            if (!tileType && touchingTiles[direction] === tileType) {
                return true;
            } else if (!tileType) {
                let nonNull = 0;
                for (let tiles of Object.values(touchingTiles)) {
                    if (!tiles) {
                        trueCount ++;
                    }
                    else {
                        nonNull ++;
                    }
                }
                if (enclosedness) {
                    return trueCount === direction && nonNull === enclosedness ? true : false;
                } else {
                    return trueCount >= direction ? true : false;
                }
            }
            if (isNaN(Number(direction))) {
                if (!tileType.includes('non')) {
                    return (touchingTiles[direction]).className === tileType ? true : false;
                } else {
                    return (touchingTiles[direction]).className != tileType.slice(3) ? true : false;
                }
            } else if (!enclosedness) {
                for (let tiles of Object.values(touchingTiles)) {
                    if (!tileType.includes('non') && tiles) {
                        tiles.className === tileType ? trueCount ++ : trueCount += 0;
                    } else if (tiles) {
                        tiles.className != tileType.slice(3) ? trueCount ++ : trueCount += 0;
                    }
                }
                return trueCount === direction ? true : false;
            } else {
                for (let tiles of Object.values(touchingTiles)) {
                    !innerArea.includes(tiles) && tiles.className != tileType ? trueCount ++ : trueCount += 0;
                }
                return trueCount >= direction ? true : false;
            }
        }

        function topToBottom(a, b) {
            return a.id[0] > b.id[0] ? 1 : -1;
        }

        function leftToRight(a, b) {
            return Number(a.id.slice(1,3)) - Number(b.id.slice(1, 3));
        }

        let turnFrozen;

        function toggleTurns() {
            let toggleButton = document.getElementById('toggle');
            turnToggle === 'on' ? turnToggle = 'off' : turnToggle = 'on';
            if (turnToggle === 'on') {
                turnFrozen = turnCount;
                toggleButton.innerHTML = "Turns: Off"
                toggleButton.setAttribute('style', 'margin: 0.5% 47.5%; width: 100px; color: red; font-weight: bold');
            } else {
                turnCount = turnFrozen;
                toggleButton.innerHTML = "Turns: On"
                toggleButton.setAttribute("style", "margin: 0.5% 47.5%; width: 100px; color: green; font-weight: bold");
            }
        }

        function logMove() {
            let movementLog = document.getElementById('movementLog');
            log = '';
            for (let move of movements) {
                log += `${move}\n`;
            }
            if (visibilityToggle === 'off') {
                movementLog.innerHTML = log;
            }
        }

        let visibilityToggle = 'on'

        function makeVisible() {
            let movementLog = document.getElementById('movementLog');
            visibilityToggle === 'on' ? visibilityToggle = 'off' : visibilityToggle = 'on';
            if (visibilityToggle === 'off') {
                movementLog.setAttribute("style", "visibility: visible")
                log != '' ? movementLog.innerHTML = log : movementLog.innerHTML = 'No Moves to Report!';
             } else {
                movementLog.setAttribute("style", "visibility: hidden");
                movementLog.innerHTML = '';
             }
        }

        function turnProgress(piece, tile) {
            turn ++;
            if (piece != 'knight') {
                movements.push(`${piece.color[0].toUpperCase()}${piece.color.slice(1, piece.color.length)} ${piece.type}: ${selected.tile.id} to ${tile.id}`);
            } else {
                movements.push(`${tile.className[0].toUpperCase()}${tile.className.slice(1, tile.className.indexOf('T'))} knight: ${crossedTiles[0].id} to ${tile.id}`);
            }
            if (movements.length > 32) {
                movements.shift();
            }
            logMove();
        }

        /*function checkLivingPieces() {

        }*/

        function start() {
            // makes everything work
        }

    </script>
</body>
</html> 