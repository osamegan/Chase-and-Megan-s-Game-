<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Chess.io</title>
</head>
<body>

    <style>
    
    body {
        background-color: black;
        text-align: center;
    }

    h1 {
        color: blue;
        font-size: 50px;
        font-weight: 200;
        font-family: Impact, Haettenschweiler, 'Arial Narrow Bold', sans-serif;
    }

    h2 {
        color: blue;
        margin-top: 40px;
    }

    h2:hover {
        color: darkred;
    }

    .start {
        background-color: green;
        margin: 0% 48%;
        margin-top: 50px;
        padding: 5px;
        color: white;
        width:fit-content;
    }
    .chessboard {
        width: 0px;
        height: 0px;
        margin: auto;
        border-collapse: collapse;
        border-spacing: 0px;
        border-color: blue;
        border-style: solid;
        visibility: hidden;
    }
 /* chessboard coordanites */
    .whiteTile {
        border: 1px solid black;
        width: 30px;
        height: 30px;
        background-color: rgb(255, 255, 255);
        margin: 0px;
        border-collapse: collapse;
    }
/* White tile coordinates */
    .blackTile {
        border: 1px solid black;
        width: 30px;
        height: 30px;
        background-color: rgb(0, 0, 0);
        margin: 0px;
        border-collapse: collapse;
    }
/* Black tile coordinates */
    .redTile {
        border: 1px solid black;
        width: 30px;
        height: 30px;
        background-color: rgb(253, 103, 103);
        margin: 0px;
        border-collapse: collapse;
    }
/* red tile coordanites and coloring */
    .blueTile {
        border: 1px solid black;
        width: 30px;
        height: 30px;
        background-color: rgb(93, 93, 255);
        margin: 0px;
        border-collapse: collapse;
    }
/*  blue tile coordanites and coloring */
    .pinkTile {
        border: 1px solid black;
        width: 30px;
        height: 30px;
        background-color: rgb(226, 141, 155);
        margin: 0px;
        border-collapse: collapse;
    }
/*  pink tile coordanites and coloring */
    .orangeTile {
        border: 1px solid black;
        width: 30px;
        height: 30px;
        background-color: rgb(231, 137, 14);
        margin: 0px;
        border-collapse: collapse;
    }

    .yellowTile {
        border: 1px solid black;
        width: 30px;
        height: 30px;
        background-color: rgb(255, 242, 61);
        margin: 0px;
        border-collapse: collapse;
    }

    .greenTile {
        border: 1px solid black;
        width: 30px;
        height: 30px;
        background-color: green;
        margin: 0px;
        border-collapse: collapse;
    }

    .silverTile {
        border: 1px solid black;
        width: 30px;
        height: 30px;
        background-color: rgb(124, 124, 124);
        margin: 0px;
        border-collapse: collapse;
    }

    .goldTile {
        border: 1px solid black;
        width: 30px;
        height: 30px;
        background-color: rgb(228, 194, 0);
        margin: 0px;
        border-collapse: collapse;
    }

    .bronzeTile {
        border: 1px solid black;
        width: 30px;
        height: 30px;
        background-color: rgb(138, 96, 17);
        margin: 0px;
        border-collapse: collapse;
    }

/*  orange tile coordanites and coloring */
    .packed {
        padding: 0;
        margin: 0;
        border-collapse: collapse;
        width: 30px;
        height: 30px;
        display: inline-block;
    }

    .buttonGroup {
        margin: auto;
        text-align: center;
    }

    div {
        margin: 0% 46.25%;
        width: 150px;
        text-align: center;
        position: relative;
        color: blue;
    }

    div:hover {
        color: blueviolet;
    }

    div:hover .tooltip {
        visibility: visible;
        opacity: 1;
    }

    .tooltip {
        position: absolute;
        color: black;
        background-color: rgba(13, 45, 187, 0.678);
        font-size: 12px;
        padding: 5px 0px;
        z-index: 1;
        visibility: hidden;
        font-family: Georgia, 'Times New Roman', Times, serif;
        width: 100px;
        bottom: 200%;
        left: 17.5%;
        opacity: 0;
        transition: opacity 0.7s;
    }

    p {
        color: blue;
        font-size: 30px;
        margin-top: 40px;
        margin-bottom: 100px;
    }

    h3 {
        color: blue;
        font-size: 40px;
        font-weight: bold;
        margin-top: 0px;
    }

    select {
        border-color: darkblue;
        background-color: black;
        color: blue;
        font-family: Impact, Haettenschweiler, 'Arial Narrow Bold', sans-serif;
        font-size: 30px;
        height: 40px;
        width: 300px;
        margin-left: -80px;
    }

    input {
        border-color: darkblue;
        background-color: black;
        color: rgb(216, 17, 17);
        font-family: Impact, Haettenschweiler, 'Arial Narrow Bold', sans-serif;
        font-size: 30px;
        height: 40px;
        width: 300px;
        margin-left: -80px;
        margin-top: 0px;
    }

    button {
        border-color: rgb(168, 1, 1);
        background-color: black;
        color: red;
        font-weight: bold;
        font-family: 'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva, Verdana, sans-serif;
        font-size: 25px;
        margin-top: 120px;
    }

    .moveLog {
        visibility: hidden;
        margin: 0px 0px 0px 10px;
        background-color: lightgray;
        font-family: Cambria, Cochin, Georgia, Times, 'Times New Roman', serif;
        position: fixed;
        width: 200px;
        text-align: center;
    }

    .normal {
        margin: auto;
        height: 150px;
        position: relative;
        visibility: visible;
        width: 500px;
        background-color: rgb(5, 32, 150);
    }

    </style>
    <pre class = 'moveLog' id = 'movementLog'></pre>
    <h1 style="text-align: center;">Chess.io</h1>
    
    <div class = "normal">
        <img id = "goldKing" src="images/Gold-King.png" alt="" height = 150px width = 150px>
    </div>
    <div class = 'normal'>
        <img id = "redRookLeft" src="images/Red-Ghost-Left.png" alt="" height = 100px width = 100px>
        <img id = "blueRookLeft" src="images/Blue-Ghost-Left.png" alt="" height = 100px width = 100px>
        <img id = "pinkRookLeft" src="images/Pink-Ghost-Left.png" alt="" height = 100px width = 100px>
        <img id = "orangeRookLeft" src="images/Orange-Ghost-Left.png" alt="" height = 100px width = 100px>
    </div>
    <h2 id = 'rules'>Rules</h2>
    <h2 id = 'begin' onclick = "playerSelect()">Play Game!</h2>

    <img id = "redRookLeft" src="images/Red-Ghost-Left.png" alt="" height = 0px width = 0px>
    <img id = "blueRookLeft" src="images/Blue-Ghost-Left.png" alt="" height = 0px width = 0px>
    <img id = "pinkRookLeft" src="images/Pink-Ghost-Left.png" alt="" height = 0px width = 0px>
    <img id = "orangeRookLeft" src="images/Orange-Ghost-Left.png" alt="" height = 0px width = 0px>
    <img id = "redRookRight" src="images/Red-Ghost-Right.png" alt="" height = 0px width = 0px>
    <img id = "redRookUp" src="images/Red-Ghost-Up.png" alt="" height = 0px width = 0px>
    <img id = "redRookDown" src="images/Red-Ghost-Down.png" alt="" height = 0px width = 0px>
    <img id = "blueRookRight" src="images/Blue-Ghost-Right.png" alt="" height = 0px width = 0px>
    <img id = "blueRookUp" src="images/Blue-Ghost-Up.png" alt="" height = 0px width = 0px>
    <img id = "blueRookDown" src="images/Blue-Ghost-Down.png" alt="" height = 0px width = 0px>
    <img id = "pinkRookRight" src="images/Pink-Ghost-Right.png" alt="" height = 0px width = 0px>
    <img id = "pinkRookUp" src="images/Pink-Ghost-Up.png" alt="" height = 0px width = 0px>
    <img id = "pinkRookDown" src="images/Pink-Ghost-Down.png" alt="" height = 0px width = 0px>
    <img id = "orangeRookRight" src="images/Orange-Ghost-Right.png" alt="" height = 0px width = 0px>
    <img id = "orangeRookUp" src="images/Orange-Ghost-Up.png" alt="" height = 0px width = 0px>
    <img id = "orangeRookDown" src="images/Orange-Ghost-Down.png" alt="" height = 0px width = 0px>
    <img id = "yellowRookLeft" src="images/Yellow-Ghost-Left.png" alt="" height = 0px width = 0px>
    <img id = "yellowRookRight" src="images/Yellow-Ghost-Right.png" alt="" height = 0px width = 0px>
    <img id = "yellowRookUp" src="images/Yellow-Ghost-Up.png" alt="" height = 0px width = 0px>
    <img id = "yellowRookDown" src="images/Yellow-Ghost-Down.png" alt="" height = 0px width = 0px>
    <img id = "greenRookLeft" src="images/Green-Ghost-Left.png" alt="" height = 0px width = 0px>
    <img id = "greenRookRight" src="images/Green-Ghost-Right.png" alt="" height = 0px width = 0px>
    <img id = "greenRookUp" src="images/Green-Ghost-Up.png" alt="" height = 0px width = 0px>
    <img id = "greenRookDown" src="images/Green-Ghost-Down.png" alt="" height = 0px width = 0px>
    <img id = "blackRookLeft" src="images/Black-Ghost-Left.png" alt="" height = 0px width = 0px>
    <img id = "blackRookRight" src="images/Black-Ghost-Right.png" alt="" height = 0px width = 0px>
    <img id = "blackRookUp" src="images/Black-Ghost-Up.png" alt="" height = 0px width = 0px>
    <img id = "blackRookDown" src="images/Black-Ghost-Down.png" alt="" height = 0px width = 0px>
    <img id = "whiteRookLeft" src="images/White-Ghost-Left.png" alt="" height = 0px width = 0px>
    <img id = "whiteRookRight" src="images/White-Ghost-Right.png" alt="" height = 0px width = 0px>
    <img id = "whiteRookUp" src="images/White-Ghost-Up.png" alt="" height = 0px width = 0px>
    <img id = "whiteRookDown" src="images/White-Ghost-Down.png" alt="" height = 0px width = 0px>
    <img id = "silverRookLeft" src="images/Silver-Ghost-Left.png" alt="" height = 0px width = 0px>
    <img id = "silverRookRight" src="images/Silver-Ghost-Right.png" alt="" height = 0px width = 0px>
    <img id = "silverRookUp" src="images/Silver-Ghost-Up.png" alt="" height = 0px width = 0px>
    <img id = "silverRookDown" src="images/Silver-Ghost-Down.png" alt="" height = 0px width = 0px>
    <img id = "goldRookLeft" src="images/Gold-Ghost-Left.png" alt="" height = 0px width = 0px>
    <img id = "goldRookRight" src="images/Gold-Ghost-Right.png" alt="" height = 0px width = 0px>
    <img id = "goldRookUp" src="images/Gold-Ghost-Up.png" alt="" height = 0px width = 0px>
    <img id = "goldRookDown" src="images/Gold-Ghost-Down.png" alt="" height = 0px width = 0px>
    <img id = "bronzeRookLeft" src="images/Bronze-Ghost-Left.png" alt="" height = 0px width = 0px>
    <img id = "bronzeRookRight" src="images/Bronze-Ghost-Right.png" alt="" height = 0px width = 0px>
    <img id = "bronzeRookUp" src="images/Bronze-Ghost-Up.png" alt="" height = 0px width = 0px>
    <img id = "bronzeRookDown" src="images/Bronze-Ghost-Down.png" alt="" height = 0px width = 0px>
    <img id = "redKnight" src="images/Red-Pacman.png" alt="" height = 0px width = 0px>
    <img id = "blueKnight" src="images/Blue-Pacman.png" alt="" height = 0px width = 0px>
    <img id = "pinkKnight" src="images/Pink-Pacman.png" alt="" height = 0px width = 0px>
    <img id = "orangeKnight" src="images/Orange-Pacman.png" alt="" height = 0px width = 0px>
    <img id = "yellowKnight" src="images/Yellow-Pacman.png" alt="" height = 0px width = 0px>
    <img id = "greenKnight" src="images/Green-Pacman.png" alt="" height = 0px width = 0px>
    <img id = "blackKnight" src="images/Black-Pacman.png" alt="" height = 0px width = 0px>
    <img id = "whiteKnight" src="images/White-Pacman.png" alt="" height = 0px width = 0px>
    <img id = "silverKnight" src="images/Silver-Pacman.png" alt="" height = 0px width = 0px>
    <img id = "goldKnight" src="images/Gold-Pacman.png" alt="" height = 0px width = 0px>
    <img id = "bronzeKnight" src="images/Bronze-Pacman.png" alt="" height = 0px width = 0px>
    <img id = "redBishop" src="images/Scared-Ghost-Red.png" alt="" height = 0px width = 0px>
    <img id = "blueBishop" src="images/Scared-Ghost-Blue.png" alt="" height = 0px width = 0px>
    <img id = "pinkBishop" src="images/Scared-Ghost-Pink.png" alt="" height = 0px width = 0px>
    <img id = "orangeBishop" src="images/Scared-Ghost-Orange.png" alt="" height = 0px width = 0px>
    <img id = "yellowBishop" src="images/Scared-Ghost-Yellow.png" alt="" height = 0px width = 0px>
    <img id = "greenBishop" src="images/Scared-Ghost-Green.png" alt="" height = 0px width = 0px>
    <img id = "blackBishop" src="images/Scared-Ghost-Black.png" alt="" height = 0px width = 0px>
    <img id = "whiteBishop" src="images/Scared-Ghost-White.png" alt="" height = 0px width = 0px>
    <img id = "silverBishop" src="images/Scared-Ghost-Silver.png" alt="" height = 0px width = 0px>
    <img id = "goldBishop" src="images/Scared-Ghost-Gold.png" alt="" height = 0px width = 0px>
    <img id = "bronzeBishop" src="images/Scared-Ghost-Bronze.png" alt="" height = 0px width = 0px>
    <img id = "redKing" src="images/Red-King.png" alt="" height = 0px width = 0px>
    <img id = "blueKing" src="images/Blue-King.png" alt="" height = 0px width = 0px>
    <img id = "pinkKing" src="images/Pink-King.png" alt="" height = 0px width = 0px>
    <img id = "orangeKing" src="images/Orange-King.png" alt="" height = 0px width = 0px>
    <img id = "yellowKing" src="images/Yellow-King.png" alt="" height = 0px width = 0px>
    <img id = "greenKing" src="images/Green-King.png" alt="" height = 0px width = 0px>
    <img id = "blackKing" src="images/Black-King.png" alt="" height = 0px width = 0px>
    <img id = "whiteKing" src="images/White-King.png" alt="" height = 0px width = 0px>
    <img id = "silverKing" src="images/Silver-King.png" alt="" height = 0px width = 0px>
    <img id = "goldKing" src="images/Gold-King.png" alt="" height = 0px width = 0px>
    <img id = "bronzeKing" src="images/Bronze-King.png" alt="" height = 0px width = 0px>

    <img id = "questionMark" src = "images/Question Mark.png" alt="" height = 0px width = 0px>
<!-- names pictures -->

    <span id = 'turns' style = "color: red; visibility: hidden;">Red Player's Turn!</span>
    <div id = 'container' style = "visibility: hidden;" onclick = makeVisible()>
        <span id = 'turnCount' style = 'color: blue; visibility: hidden;'>Turn: 1</span>
        <span id = 'tooltip' class = 'tooltip'>See Recent Moves</span>
    </div>

    <table id = "chessboard"></table>

    <script>
        
        let board = document.getElementById("chessboard");
        board.setAttribute("class", "chessboard");
        let dpi = window.devicePixelRatio;
        let letters = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T'];
        let chessPieces = [];
        let selected = {};
        let crossedTiles = [];
        let innerArea = [];
        let movements = [];
        let log = '';
        let allTiles = [];
        let players = [];
        let player1 = {number: 'one', defeated: false, color: null, turn: true, AI: false};
        let player2 = {number: 'two', defeated: false, color: null, turn: false, AI: true};
        let player3 = {number: 'three', defeated: false, color: null, turn: false, AI: true};
        let player4 = {number: 'four', defeated: false, color: null, turn: false, AI: true};
        crossedTiles.fill = function(tile, color) {
            let allIds = crossedTiles.map(getId);
            let theHalf = 0;
            let ids = null;
            allIds.indexOf(tile.id) > 2 ? theHalf = 2 : theHalf = 1;
            if (theHalf === 1) {
                ids = allIds.slice(1, 3)
                crossedTiles.unfill(document.getElementById(allIds[3]));
            } else {
                ids = allIds.slice(3, 6);
                ids.push(allIds[0]);
                crossedTiles.unfill(document.getElementById(allIds[1]));
            }
            ids.forEach((square, index) => {
                let ctx = document.getElementById(square).getContext("2d");
                let questionMark = document.getElementById('questionMark');
                if (((index != 3 && theHalf === 1) || (theHalf === 2 && index != 0)) && !document.getElementById(square).piece) {
                    ctx.drawImage(questionMark,  7.5, 3.75, 275, 134.5);
                }
            })
            fillTerritory({[color]: ids});
        }
        // assigns each tile a letter and number
        crossedTiles.unfill = function(tile) {
            let theHalf = 0;
            let ids = null;
            crossedTiles.indexOf(tile) > 2 ? theHalf = 2 : theHalf = 1;
            if (theHalf === 1) {
                ids = crossedTiles.slice(0, 3);
            } else {
                ids = crossedTiles.slice(4, 6);
            }
            ids.forEach(originalColor);
        }
        crossedTiles.set = (tile) => {
            for (let square of crossedTiles) {
                square.removeAttribute("onmouseover");
                square.removeAttribute("onclick");
                square.lastColor = square.className.slice(0, square.className.indexOf('T'));
                let ctx = square.getContext("2d");
                if (!square.piece || (square.piece && (square.piece.currentColor != square.piece.color && square.className === tile.className) && square.piece.color != tile.className.slice(0, tile.className.indexOf('T')))) {
                    ctx.clearRect(0, 0, 300, 150);
                }
                if (square.piece && (square.piece.currentColor != square.piece.color && square.className === tile.className) && square.piece.color != tile.className.slice(0, tile.className.indexOf('T'))) {
                    chessPieces.splice(chessPieces.indexOf(square.piece), 1);
                    delete square.piece;
                }
            }
            if (turnToggle === "off") {
                turnProgress('knight', tile);
            }
            let knightSquare = crossedTiles[3];
            empty(crossedTiles);
            findEnclosedTiles(knightSquare);
            crossedTiles.forEach((square) => {
                square.setAttribute("class", `${tile.className}`);
                square.lastColor = tile.className.slice(0, tile.className.indexOf('T'));
            });
            empty(crossedTiles);
            let com = players.find((player) => {
                return player.turn && player.AI;
            });
            if (com) {
                setTimeout(comMove, 1, com);
            }
        }
        let turn = 1;
        let turnToggle = 'off';
        const moves = {
            rook: {
                vertical: true,
                horizontal: true,
                diagonal: false,
                knight: false,
                range: Infinity,                
                leavable: true,
                importance: 800
            },

            bishop: {
                vertical: false,
                horizontal: false,
                diagonal: true,
                knight: false,
                range: Infinity,
                leavable: true,
                importance: 1200
            },

            knight: {
                vertical: false,
                horizontal: false,
                diagonal: false,
                knight: true,
                range: undefined,
                leavable: true,
                importance: 400
            },

            king: {
                vertical: true,
                horizontal: true,
                diagonal: true,
                knight: false,
                range: 1,
                leavable: false,
                importance: Infinity
            }
        };
        //gives each piece their possible moves

        function setBoard() {
            board.setAttribute('style', 'visibility: visible;');
            let container = document.getElementById('container');
            container.removeAttribute('style', 'visibility: hidden;');
            let turns = document.getElementById('turns');
            turns.removeAttribute('style', 'visibility: hidden;');
            turns.setAttribute('style', 'margin-left: 0px;');
            let currentPlayer = players.find((player) => {
                return player.turn;
            });
            turns.innerHTML = `${currentPlayer.color[0].toUpperCase()}${currentPlayer.color.slice(1, currentPlayer.color.length)} Player's Turn!`
            turns.setAttribute('style', `color: ${players[0].color != 'black' && players[0].color != 'bronze' ? players[0].color : players[0].color === 'black' ? 'rgb(24, 24, 24)' : 'brown'}`);
            document.getElementById('turnCount').removeAttribute('style','visibility: hidden;');
            let toggleButton = document.createElement("BUTTON");
            toggleButton.setAttribute("onclick", "toggleTurns()");
            toggleButton.innerHTML = "Turns: On";
            toggleButton.id = 'toggle';
            toggleButton.setAttribute("style", "margin: 0.5% 47.5%; width: 100px; color: green; font-weight: bold");
            //document.body.appendChild(toggleButton);
            let start = document.createElement("BUTTON");
            start.setAttribute("class", "start");
            start.id = "start";
            start.innerHTML = "Start Game";
            start.setAttribute("onclick", "start()");
            //document.body.appendChild(start);
            createBoard();
        }
// sets the board
        function createBoard() {
            let start = document.getElementById('start');
            let letterNum = 0;
            let number = 1;
            for (let columnLength = 0; columnLength < 20; columnLength ++) {
                let column = document.createElement("TR");
                column.setAttribute("class", "packed");
                for (let rowLength = 0; rowLength < 20; rowLength ++) {
                    let row = document.createElement("TD");
                    row.setAttribute("class", "packed");
                    let tile = document.createElement("CANVAS");
                    tile.id = `${letters[letterNum]}${number}`
                    tile.setAttribute("class", "packed");
                    tile.width = 20 * dpi;
                    tile.height = 20 * dpi;
                    tile.addEventListener('click', click);
                    if (columnLength  % 2 === 0) {
                        if (rowLength % 2 === 0) {
                            tile.setAttribute("class", "whiteTile");
                            tile.firstColor = 'white';
                        } else {
                            tile.setAttribute("class", "blackTile");
                            tile.firstColor = 'black';
                        }
                    } else {
                        if (rowLength % 2 != 0) {
                            tile.setAttribute("class", "whiteTile");
                            tile.firstColor = 'white';
                        } else {
                            tile.setAttribute("class", "blackTile");
                            tile.firstColor = 'black';
                        }
                    }
                    tile.lastColor = tile.className.slice(0, tile.className.indexOf('T'));
                    row.appendChild(tile);
                    column.appendChild(row);
                    letterNum ++;
                    allTiles.push(tile);
                }
                board.appendChild(column);
                letterNum = 0;
                number ++;
            }
            document.body.appendChild(board);
        }

        let bot;

        function click(event) {
            let tile;
            if (typeof(event) === 'string') {
                tile = document.getElementById(event);
            } else {
                tile = event.toElement;
            }
            if (selected.piece && checkLegality(selected.piece, tile.id) === 'legal' && !(Array.from(document.getElementsByTagName("CANVAS")).some(function(tile) {
                if (tile.onmouseover) {
                    return true;
                }
            })) && isTurnLegal(selected.piece.color) && selected.tile.id === selected.piece.currentPos) {
                bot = null;
                moveTo(selected.piece, tile.id);
                if (!crossedTiles.some(function(tile) {
                    return tile.currentColor ? false : true;
                })) {
                    crossedTiles.forEach(setLastColor);
                }
                selected.piece.type === 'knight' ? crossedTiles.slice(0, 4).forEach(setCurrentColor) : crossedTiles.forEach(setCurrentColor);
                selected.tile.setAttribute("style", "border: 1px solid black");
                let ctx = selected.tile.getContext("2d");
                ctx.clearRect(0, 0, selected.tile.width, selected.tile.height);
                if (selected.piece.type === 'knight' && crossedTiles.some((square) => {
                    return square.className != tile.className;
                })) {
                    ctx.drawImage(questionMark,  7.5, 3.75, 275, 134.5);
                }
                let com = players.find((player) => {
                    return player.turn && player.AI;
                });
                if (com && selected.piece.type != 'knight') {
                    delete selected.piece;
                    delete selected.tile.piece;
                    delete selected.tile;
                    setTimeout(comMove, 1, com);
                } else {
                    delete selected.piece;
                    delete selected.tile.piece;
                    delete selected.tile;
                }
            } else if (!(Array.from(document.getElementsByTagName("CANVAS")).some(function(tile) {
                if (tile.onmouseover) {
                    return true;
                }
            }))) {
                empty(crossedTiles);
                tile.setAttribute("style", "border: 1px blue");
                selected.tile ? selected.tile.setAttribute("style", "border: 1px solid black") : selected.tile = tile;
                selected.tile = tile;
                tile.piece ? selected.piece = tile.piece : tile.piece = null;
            }
        }

        let captureCount = 0;
        let piecesRemoved = [];
        let otherPlayersTileCount = 0;

        function comMove(com) {
            console.log(`${com.color[0].toUpperCase()}${com.color.slice(1, com.color.length)} Com is thinking...`);
            bot = true;
            otherPlayersTileCount = 0;
            let othersBestMoves = otherPlayersBestMoves(com);
            let comTilesToClick = allTiles.filter((tile) => {
                return tile.piece && tile.piece.belongsTo === com;
            });
            let comMoves = [];
            for (let piece of comTilesToClick) {
                for (let tile of allTiles.filter((tile) => {
                        let isTrue = false;
                        if (checkLegality(piece.piece, tile.id) === 'legal') {
                            isTrue = true;
                        }
                        empty(crossedTiles);
                        return isTrue;
                    })) {
                    if (checkLegality(piece.piece, tile.id) === 'legal') {
                        tile.className = piece.className
                        findPotentialInnerArea(tile);
                        tile.className = `${tile.lastColor}Tile`;
                        tile.piece = piece.piece;
                        let colorNumber = crossedTiles.filter((square) => {
                            return square.className != tile.className;
                        }).length + (piecesRemoved[0] ? piecesRemoved.map((piece) => {
                            return piece.importance;
                        }).reduce((total, current) => {
                            return total + current;
                        }) : 0);
                        for (let move of othersBestMoves) {
                            if (checkLegality(move[0], move[1]) === 'legal') {
                                piecesRemoved = [];
                                document.getElementById(move[1]).className = `${move[0].color}Tile`;
                                findPotentialInnerArea(move[1]);
                                document.getElementById(move[1]).className = `${document.getElementById(move[1]).lastColor}Tile`;
                                otherPlayersTileCount += crossedTiles.filter((square) => {
                                    return square.className != `${move[0].color}Tile`;
                                }).length + (piecesRemoved[0] ? piecesRemoved.map((piece) => {
                                    return piece.importance;
                                }).reduce((total, current) => {
                                    return total + current;
                                }) : 0);
                            }
                            empty(crossedTiles);
                        }
                        tile.piece = null;
                        colorNumber -= otherPlayersTileCount;
                        comMoves.push([piece.piece, tile, piece.piece === 'knight' ? colorNumber - 3 : colorNumber, crossedTiles]);
                        otherPlayersTileCount = 0;
                    }
                    empty(crossedTiles);
                }
            }
            let bestMove = findBestMove(com, comMoves, comTilesToClick);
            console.log(`${com.color[0].toUpperCase()}${com.color.slice(1, com.color.length)} Com is moving their piece now...`);
            click(bestMove[0].currentPos);
            click(bestMove[1].id);
            if (bestMove[0].type === 'knight') {
                crossedTiles.set(bestMove[1]);
                /*let option1 = Array.from(document.getElementsByClassName(`${com.color}Tile`));
                crossedTiles.fill(crossedTiles[4], com.color);
                crossedTiles.set(crossedTiles[4]);
                let option2 = Array.from(document.getElementsByClassName(`${com.color}Tile`));
                if (option1.length > option2.length || option1) {

                }*/
            }
        }

        function otherPlayersBestMoves(com) {
            let otherPlayersMoves = [];
            let bestMoves = [];
            for (let player of players.filter((player) => {
                return player != com;
            })) {
                for (let pieceTile of allTiles.filter((tile) => {
                    return tile.piece && tile.piece.belongsTo === player;
                })){
                    for (let tile of allTiles.filter((tile) => {
                        let isTrue = false;
                        if (checkLegality(pieceTile.piece, tile.id) === 'legal') {
                            isTrue = true;
                        }
                        empty(crossedTiles);
                        return isTrue;
                    })) {
                        checkLegality(pieceTile.piece, tile.id);
                        tile.className = pieceTile.className;
                        findPotentialInnerArea(tile);
                        tile.className = `${tile.lastColor}Tile`;
                        let colorNumber = crossedTiles.filter((square) => {
                            return square.className != pieceTile.className;
                        }).length;
                        otherPlayersMoves.push([pieceTile.piece, tile.id, colorNumber + (piecesRemoved[0] ? piecesRemoved.reduce((total, current) => {
                            return total + current.importance;
                        }) : 0)]);
                        empty(crossedTiles);
                    }
                }
                bestMoves.push(otherPlayersMoves.find((move) => {
                    return move[2] === Math.max.apply(null, otherPlayersMoves.map((move) => {
                        return move[2];
                    }));
                }).slice(0, 2));
                otherPlayersMoves = [];
            }
            console.log(bestMoves);
            return bestMoves;
        }

        function findBestMove(com, comMoves, comTilesToClick) {
            console.log(`${com.color[0].toUpperCase()}${com.color.slice(1, com.color.length)} Com is finding the best move...`);
            findBestSetup(com, comMoves, comTilesToClick);
            console.log(`${com.color[0].toUpperCase()}${com.color.slice(1, com.color.length)} Com has just finished finding the best set-up...`);
            console.log(comMoves);
            return comMoves.find((move) => {
                return move[2] === Math.max.apply(null, comMoves.map((move) => {
                    return move[2];
                    })
                );
            });
        }

        function findBestSetup(com, comMoves, comTilesToClick) {
            for (let nextMove of comMoves) {
                let nextTile = document.getElementById(nextMove[0].currentPos);
                nextTile.piece  = nextMove[0];
                for (let square of allTiles.filter((tile) => {
                        let isTrue = false;
                        if (checkLegality(nextTile.piece, tile.id) === 'legal') {
                            isTrue = true;
                        }
                        empty(crossedTiles);
                        return isTrue;
                    })) {
                        if (checkLegality(nextTile.piece, square.id) === 'legal') {
                            square.className = nextTile.className;
                            findPotentialInnerArea(square);
                            square.className = `${square.lastColor}Tile`;
                            let colorNumber = crossedTiles.filter((tile) => {
                                return tile.className != square.className;
                            }).length 
                            square.piece === 'knight' ? nextMove[2] += colorNumber - 3 : nextMove[2] += colorNumber;
                        }
                    empty(crossedTiles);
                }
            }
        }

        function playerSelect() {
            players.push(player1, player2, player3, player4);
            document.body.removeChild(document.getElementById('rules'));
            document.body.removeChild(document.getElementById('begin'));
            Array.from(document.getElementsByClassName('normal')).forEach((element) => {
                document.body.removeChild(element);
            });
            let playerSelect = document.createElement("SELECT");
            let p = document.createElement('P');
            p.innerHTML = 'Select Number of Players';
            p.id = 'p';
            playerSelect.id = 'playerSelect';
            for (let player of players) {
                let playerCount = document.createElement("OPTION");
                playerCount.innerHTML = `${player.number[0].toUpperCase()}${player.number.slice(1, player.number.length)}-Player Game`;
                playerSelect.appendChild(playerCount);
            }
            document.body.appendChild(p);
            let buttonGroup = document.createElement("DIV");
            buttonGroup.id = 'buttonGroup';
            buttonGroup.className = 'buttonGroup';
            buttonGroup.appendChild(playerSelect);
            document.body.appendChild(buttonGroup);
            let confirm = document.createElement('BUTTON');
            confirm.innerHTML = 'Confirm';
            confirm.setAttribute('onclick', 'nameSelect()');
            buttonGroup.appendChild(confirm);
        }

        let stop = 'zero';

        function nameSelect() {
            if (document.getElementById('p')) {
                document.body.removeChild(document.getElementById('p'));
            }
            let currentPlayer = players.find((player) => {
                return player.turn === true;
            });
            if (currentPlayer === player1) {
                let select = document.getElementById('playerSelect');
                stop = select.value.slice(0, select.value.indexOf('-')).toLowerCase();
                document.body.removeChild(document.getElementById('buttonGroup'));
            }
            let player = document.createElement("H3");
            player.innerHTML = `Player ${currentPlayer.number[0].toUpperCase()}${currentPlayer.number.slice(1, currentPlayer.number.length)}`;
            player.id = `Player`;
            document.body.appendChild(player);
            let p = document.createElement('P');
            p.innerHTML = "Enter the name of your kingdom";
            p.id = 'p';
            document.body.appendChild(p);
            let kingdomName = document.createElement("INPUT");
            kingdomName.id = 'name';
            let confirm = document.createElement("BUTTON");
            confirm.innerHTML = 'Confirm';
            confirm.id = 'confirm';
            confirm.onclick = function() {
                currentPlayer.kingdomName = kingdomName.value;
            }
            confirm.addEventListener('click', colorSelect);
            let buttonGroup = document.createElement("DIV");
            buttonGroup.id = 'buttonGroup';
            buttonGroup.className = 'buttonGroup';
            document.body.appendChild(buttonGroup);
            buttonGroup.appendChild(kingdomName);
            buttonGroup.appendChild(confirm);
        }

        function colorSelect() {
            document.body.removeChild(document.getElementById('p'));
            document.body.removeChild(document.getElementById('buttonGroup'));
            let player = players.find((player) => {
                return player.turn;
            });
            let choice = document.createElement("SELECT");
            let colors = ["Red", "Blue", "Pink", "Orange", "Yellow", "Green", "Black", "White", "Silver", "Gold", "Bronze"];
            let takenColors = players.filter((player) => {
                return player.color;
            }).map((player) => {
                return player.color[0].toUpperCase().concat(player.color.slice(1, player.color.length));
            });
            takenColors.forEach((color) => {
                colors.splice(colors.indexOf(color), 1);
            });
            for (let color of colors) {
                let option = document.createElement("OPTION");
                option.innerHTML = color;
                option.setAttribute('style', `color: ${color != "Black" && color != "Bronze" ? color.toLowerCase() : color === "Black" ? 'rgb(24, 24, 24)' : 'brown'}`);
                choice.appendChild(option);
            }
            choice.setAttribute('style', 'color: red');
            choice.addEventListener('change', function() {
                choice.setAttribute('style', `color: ${choice.value.toLowerCase() != "black" && choice.value.toLowerCase() != "bronze" ? choice.value.toLowerCase() : choice.value.toLowerCase() === "black" ? 'rgb(24, 24, 24)' : 'brown'}`);
            });
            let p = document.createElement("P");
            p.innerHTML = "Choose your kingdom's color";
            p.id = 'p';
            document.body.appendChild(p);
            choice.id = player.number;
            let buttonGroup = document.createElement("DIV");
            buttonGroup.id = 'buttonGroup';
            buttonGroup.className = 'buttonGroup';
            document.body.appendChild(buttonGroup);
            buttonGroup.appendChild(choice);
            let confirm = document.createElement("BUTTON");
            confirm.innerHTML = 'Confirm';
            confirm.id = 'confirm';
            confirm.setAttribute('onclick', 'setColor()');
            buttonGroup.appendChild(confirm);
        }

        function setColor() {
            let player = players.find((player) => {
                return player.turn;
            });
            player.color = document.getElementById(player.number).value.toLowerCase();
            player.turn = false;
            if (players.indexOf(player) != 3 && stop != player.number) {
                players[players.indexOf(player) + 1].turn = true;
                player.AI = false;
                document.body.removeChild(document.getElementById('buttonGroup'));
                document.body.removeChild(document.getElementById('p'));
                let ready = document.createElement("H3");
                ready.id = 'ready';
                ready.innerHTML = `Ready ${document.getElementById('Player').innerHTML}!`;
                ready.setAttribute('style', 'color: red; font-family: impact; margin: 100px');
                document.body.removeChild(document.getElementById('Player'));
                document.body.appendChild(ready);
                setTimeout(readyPlayer, 3000);
            } else {
                player.AI = false;
                document.body.removeChild(document.getElementById('buttonGroup'));
                document.body.removeChild(document.getElementById('p'));
                players.slice(players.indexOf(player) + 1, players.length).forEach((player, index) => {
                    player.AI = true;
                    let defaultColors = ['red', 'blue', 'pink', 'orange'];
                    let freeDefaultColors = defaultColors.filter((color) => {
                        return players.every((player) => {
                            return player.color != color;
                        });
                    });
                    player.color = freeDefaultColors[index];
                });
                players.forEach((player) => {
                    player.turn = false;
                });
                player1.turn = true;
                let ready = document.createElement("H3");
                ready.id = 'ready';
                ready.innerHTML = `Ready ${document.getElementById('Player').innerHTML}!`;
                ready.setAttribute('style', 'color: red; font-family: impact; margin: 100px;');
                document.body.removeChild(document.getElementById('Player'));
                document.body.appendChild(ready);
                setTimeout(readyPlayer, 3000);
            }
        }

        function readyPlayer() {
            let ready = document.getElementById('ready');
            document.body.removeChild(ready);
            player1.turn === true ? chooseColor() : nameSelect();
        }

        function chooseColor() {
            let colors = [];
            for (let player of players) {
                colors.push(player.color);
            }
            setBoard();
            setPieces(colors);
        }
// names each color
        function setPieces(colors) {
            for (let color of colors) {
                createPiece('Rook', color, 1);
                createPiece('Rook', color, 2);
                createPiece('Bishop', color, 1);
                createPiece('Bishop', color, 2)
                createPiece('Knight', color, 1);
                createPiece('Knight', color, 2);
                createPiece('King', color, 1);
            }
            let positions = ["C2", "A3", "C1", "B3", "B2", "C3", "A1", "B18", "C20", "A18", "C19", "C18", "B19", "A20", "R1", "S3", "R2", "T3", "S2", "R3", "T1", "T18", "R19", "S18", "R20", "R18", "S19", "T20"];
            for (let pieces in chessPieces) {
                let position = positions[pieces];
                if (position) {
                    let tile = document.getElementById(position)
                    let ctx = tile.getContext("2d");
                    if (chessPieces[pieces].type != 'rook') {
                        tile.width = 20 * dpi;
                        tile.height = 20 * dpi;
                        ctx.drawImage(chessPieces[pieces].image, 0, 0, 20, 20);
                    } else {
                        let imageType;
                        position === 'A3'|| position === 'S3' ? imageType = 'rightImage' : position === 'B18' || position === 'T18' ? imageType = 'leftImage' : position === 'C2' || position === 'C20' ? imageType = 'downImage' : imageType = 'upImage';
                        tile.width = 20 * dpi;
                        tile.height = 20 * dpi;
                        ctx.drawImage(chessPieces[pieces][imageType], 0, 0, 20, 20);
                    }
                    tile.setAttribute("class", `${chessPieces[pieces].color}Tile`);
                    tile.piece = chessPieces[pieces];
                    tile.lastColor = chessPieces[pieces].color;
                    chessPieces[pieces].currentPos = position;
                }
            }
            let object = {};
            object[player1.color] = ['A2', 'B1'];
            object[player2.color] = ['A19', 'B20'];
            object[player3.color] = ['S1', 'T2'];
            object[player4.color] = ['S20', 'T19'];
            fillTerritory(object);
        }
// gives the pieces' positions
        function createPiece(type, color, number) {
            let piece = {};
            if (type != 'Rook') {
                piece.image = new Image();
                piece.image.src = document.getElementById(`${color}${type}`).src;
            } else {
                piece.leftImage = new Image();
                piece.leftImage.src = document.getElementById(`${color}${type}Left`).src;
                piece.rightImage = new Image();
                piece.rightImage.src = document.getElementById(`${color}${type}Right`).src;
                piece.upImage = new Image();
                piece.upImage.src = document.getElementById(`${color}${type}Up`).src;
                piece.downImage = new Image();
                piece.downImage.src = document.getElementById(`${color}${type}Down`).src;
            }
            piece.type = type.toLowerCase();
            piece.color = color;
            piece.id = `${color}${type}${number}`;
            piece.movability = moves[piece.type]
            piece.importance = moves[piece.importance];
            piece.belongsTo = players.find((player) => {
                return player.color === piece.color;
            });
            chessPieces.push(piece);
        }
// creates the pieces
        function moveTo(piece, square) {
            let tile = document.getElementById(square);
            let ctx = tile.getContext("2d");
            if (piece.type != 'rook') {
                ctx.drawImage(piece.image, 0, 0, 20, 20);
            } else {
                let imageType;
                if (selected.tile.id[0] != tile.id[0]) {
                    selected.tile.id[0] < tile.id[0] ? imageType = 'downImage' : imageType = 'upImage';
                }
                if (Number(selected.tile.id.slice(1, 3)) != Number(tile.id.slice(1, 3))) {
                    Number(selected.tile.id.slice(1, 3)) < Number(tile.id.slice(1, 3)) && !imageType ? imageType = 'rightImage' : imageType = 'leftImage';
                }
                ctx.drawImage(piece[imageType], 0, 0, 20, 20);
            }
            tile.setAttribute("class", `${piece.color}Tile`);
            tile.lastColor = selected.piece.color;
            tile.piece = piece;
            piece.currentPos = square;
            if (piece.type != 'knight' || !crossedTiles.some((square) => {
                return square.className != tile.className;
            })) {
                crossedTiles.forEach(color);
                findEnclosedTiles(tile);
                crossedTiles.forEach(color);
                if (turnToggle === "off") {
                    turnProgress(piece, tile);
                }
        }
            if (piece.type === 'knight' && crossedTiles.some((square) => {
                return square.className != tile.className;
            })) {
                (crossedTiles.filter((tile, index) => {
                    return index < 4;
                })).forEach(color);
                userSelect();
            } else {
                empty(crossedTiles);
            }
        }
// makes the pieces move
        function checkLegality(piece, square) {
            let tile = document.getElementById(square);
            let startNumber = Number(piece.currentPos.slice(1, 3));
            let endNumber = Number(square.slice(1, 3));
            let moveType = null;
            let slope = (letters.indexOf(piece.currentPos[0]) + 1 - (letters.indexOf(square[0]) + 1)) / (startNumber - endNumber);
            let ranged = null;
            let distance = findDistance(startNumber, endNumber, letters.indexOf(piece.currentPos[0]) + 1, letters.indexOf(square[0]) + 1);
            Math.abs(letters.indexOf(piece.currentPos[0]) + 1 - (letters.indexOf(square[0]) + 1)) > 1 || Math.abs(startNumber - endNumber) > 1 ? ranged = true : ranged = false;
            if (piece.currentPos[0] === square[0]) {
                moveType = 'horizontal';
            } else if (startNumber === endNumber){
                moveType = 'vertical';
            } else if (Math.abs(slope) === 1) {
                moveType = 'diagonal';
            } else if (distance === Math.sqrt(5)) {
                moveType = 'knight';
            } else {
                moveType = 'invalid';
            }
            if (tile.piece || (piece.type === 'king' && (ranged === true || tile.className.slice(0, tile.className.indexOf('T')) != piece.color)) || !piece.movability[moveType]) {
                jurisdiction = 'illegal';
            } else {
                jurisdiction = 'legal';
                logCrossedTiles(moveType, piece.currentPos, square, slope);
                if (crossedTiles.some((tile) => {
                    return tile.piece;
                }) && piece.type != 'knight') {
                    jurisdiction = 'illegal';
                }
            }
            return jurisdiction;
        }

// checks the legality of the moves

    function findDistance(x1, x2, y1, y2) {
        return Math.sqrt(Math.pow((x2-x1), 2) + Math.pow((y2-y1), 2));
    }
        function logCrossedTiles(moveType, start, end, slope) {
            let idLetter = start[0];
            let idNumber = Number(start.slice(1, 3));
            let endLetter = end[0];
            let endNumber = Number(end.slice(1, 3));
            let round = 0;
            for (let tile = document.getElementById(start); tile.id != end; tile = document.getElementById(`${idLetter}${idNumber}`)) {
                crossedTiles.push(tile);
                if (moveType === 'knight') {
                    round ++;
                    Math.abs(slope) > 1 ? round < 3 ? moveType = 'vertical' : moveType = 'horizontal' : round < 3 ? moveType = 'horizontal' : moveType = 'vertical';
                }
                moveType === 'horizontal' ? idLetter = idLetter : endLetter > idLetter ? idLetter = letters[letters.indexOf(idLetter) + 1] : idLetter = letters[letters.indexOf(idLetter) - 1];
                moveType === 'vertical' ? idNumber = idNumber : endNumber > idNumber ? idNumber ++ : idNumber --;
                round === 0 ? moveType = moveType : moveType = 'knight';
                if (round === 3) {
                    if (end === start) {
                        return;
                    }
                    end = start;
                    endLetter = end[0];
                    endNumber = Number(end.slice(1, 3));
                    round = 0;
                }
            }
            if (moveType != 'knight') {
                crossedTiles.shift();
            }
        }

        function fillTerritory(obj) {
            let colors = Object.keys(obj);
            for (let color of colors) {
                let ids = obj[color];
                for (let id of ids) {
                    let tile = document.getElementById(id);
                    tile.setAttribute('class', `${color}Tile`);
                    if (turn === 1 && crossedTiles.length != 6) {
                        tile.lastColor = color;
                    }
                }
            }
        }

        function userSelect() {
            for (let tile in crossedTiles) {
                if (Number(tile) < 6) {
                    crossedTiles[tile].setAttribute("onclick", "crossedTiles.set(this)");
                    if (Number(tile) < 3) {
                        crossedTiles[tile].setAttribute("onmouseover", "crossedTiles.fill(this, this.currentColor)");
                    } else {
                        crossedTiles[tile].setAttribute("onmouseover", "crossedTiles.fill(this, crossedTiles[0].currentColor)");
                    }
                }
            }
        }
// lets the player click on the tiles
        function empty(array) {
            while (array.length > 0) {
                array.shift();
            }
        }
// empties the array
        function color(tile) {
            tile.setAttribute("class", `${selected.piece.color}Tile`);
            if (selected.piece.type != 'knight' || !crossedTiles.some((square) => {
                return square.className != tile.className;
            }))  {
                tile.lastColor = selected.piece.color;
            } else {
                let questionMark = document.getElementById('questionMark');
                let ctx = tile.getContext("2d");
                if (crossedTiles.indexOf(tile) != 3 && !tile.piece) {
                    ctx.drawImage(questionMark,  7.5, 3.75, 275, 134.5);
                }
            }
        }
// colors the tile
        function originalColor(tile) {
            tile.setAttribute('class', `${tile.lastColor}Tile`);
            let ctx = tile.getContext("2d");
            if (!tile.piece) {
                ctx.clearRect(0, 0, 300, 150);
            }
        }
// gives the tile its original color
        function getId(canvas) {
            return canvas.id;
        }
// gets the canvas id
        function setCurrentColor(item) {
            item.currentColor = selected.piece.color;
        }
// gives the original color
        function setLastColor(item) {
            item.lastColor = item.currentColor;
        }
// sets the item's last color
        function isTurnLegal(color) {
            if (turnToggle === 'on') {
                return true; //THIS IS TEMPORARY!!!
            }
            let player = players.find((player) => {
                return player.turn === true;
            });
            let rightfulColor = player.color;
            return rightfulColor === color ? true : false;
        }

        function findEnclosedTiles(tile) {
            empty(innerArea);
            let coloredTiles = Array.from(document.getElementsByClassName(`${tile.className}`)).map(toIds);
            let topmostTiles = ((((coloredTiles.sort()).reverse()).filter(noRepeatingNumbers)).map(backToElements)).sort(leftToRight);
            let bottommostTiles = (((coloredTiles.sort()).filter(noRepeatingNumbers)).map(backToElements)).sort(leftToRight);
            let rightmostTiles = (((coloredTiles.sort(function (a, b) {
                return Number(a.slice(1, 3)) - Number(b.slice(1, 3));
            })).filter(noRepeatingLetters)).map(backToElements)).sort(topToBottom);
            let leftmostTiles = (((coloredTiles.sort(function (a, b) {
                return Number(b.slice(1, 3)) - Number(a.slice(1, 3));
            })).filter(noRepeatingLetters)).map(backToElements)).sort(topToBottom);
            let nonpolygon = Array.from(document.getElementsByTagName('CANVAS')).filter((square) => {
                return square.className != tile.className
            });
            topmostTiles = topmostTiles.concat(nonpolygon.filter((square) => {
                return touches(square, null, 'aboveTile') && topmostTiles.find((correspondingTile) => {
                    return Number(correspondingTile.id.slice(1, 3)) === Number(square.id.slice(1, 3));
                });
            })).map(toIds).filter(noRepeatingNumbers).map(backToElements).sort(leftToRight);
            bottommostTiles = bottommostTiles.concat(nonpolygon.filter((square) => {
                return touches(square, null, 'belowTile') && bottommostTiles.find((correspondingTile) => {
                    return Number(correspondingTile.id.slice(1, 3)) === Number(square.id.slice(1, 3));
                });
            })).map(toIds).filter(noRepeatingNumbers).map(backToElements).sort(leftToRight);
            leftmostTiles = leftmostTiles.concat(nonpolygon.filter((square) => {
                return touches(square, null, 'leftTile') && leftmostTiles.find((correspondingTile) => {
                    return correspondingTile.id[0] === square.id[0];
                });
            })).map(toIds).filter(noRepeatingLetters).map(backToElements).sort(topToBottom);
            rightmostTiles = rightmostTiles.concat(nonpolygon.filter((square) => {
                return touches(square, null, 'rightTile') && rightmostTiles.find((correspondingTile) => {
                    return correspondingTile.id[0] === square.id[0];
                });
            })).map(toIds).filter(noRepeatingLetters).map(backToElements).sort(topToBottom);;
            innerArea = nonpolygon.filter((square) => {
                if (topmostTiles.find((correspondingTile) => {
                    return Number(correspondingTile.id.slice(1, 3)) === Number(square.id.slice(1, 3));
                }) && bottommostTiles.find((correspondingTile) => {
                    return Number(correspondingTile.id.slice(1, 3)) === Number(square.id.slice(1, 3));
                }) && leftmostTiles.find((correspondingTile) => {
                    return correspondingTile.id[0] === square.id[0];
                }) && rightmostTiles.find((correspondingTile) => {
                    return correspondingTile.id[0] === square.id[0];
                })) {
                    if (letters.indexOf(square.id[0]) >= letters.indexOf((topmostTiles.find((correspondingTile) => {
                        return Number(correspondingTile.id.slice(1, 3)) === Number(square.id.slice(1, 3));
                    })).id[0]) && letters.indexOf(square.id[0]) <= letters.indexOf((bottommostTiles.find((correspondingTile) => {
                        return Number(correspondingTile.id.slice(1, 3)) === Number(square.id.slice(1, 3));
                    })).id[0]) && (Number(square.id.slice(1, 3)) >= Number((leftmostTiles.find((correspondingTile) => {
                        return correspondingTile.id[0] === square.id[0];
                    })).id.slice(1, 3))) && Number(square.id.slice(1, 3)) <= Number((rightmostTiles.find((correspondingTile) => {
                        return correspondingTile.id[0] === square.id[0];
                    })).id.slice(1, 3))) {
                        return true;
                    } else {
                        return false;
                    }
                } else {
                    return false;
                }
            });
            let broken = false;
            if (innerArea.length > 0) {
                broken = true;
            }
            if (innerArea.some((square) => {
                return square.piece && square.piece.type === 'bishop';
            })) {
                let bishopTile = innerArea.find((square) => {
                    return square.piece && square.piece.type === 'bishop';
                })
                if (bishopContinuityTest(bishopTile)) {
                    return;
                }
            }
            while (broken) {
                innerArea.sort(function (a, b) {
                    return touches(a, `${tile.className}`, 1, 'unclosed') ? -1 : 1;
                });
                for (let square of innerArea) {
                    if (touches(square, `${tile.className}`, 1, 'unclosed')) {
                        innerArea.splice(innerArea.indexOf(square), 1);
                        break;
                    } else {
                        crossedTiles.unshift(square);
                        if (innerArea.indexOf(square) === innerArea.length - 1) {
                            broken = false;
                        }
                    }
                }
                if (innerArea.length === 0) {
                    broken = false;
                }
            }
            let i = 0;
            while (innerArea.find((square,index) => {
                return square.piece && index >= i;
            })) {
                let square = innerArea.find((square, index) => {
                    return square.piece && index >= i;
                });
                i ++;
                if (square && square.piece.type === 'king') {
                    let stolenTerritory = Array.from(document.getElementsByClassName(`${square.piece.color}Tile`))
                    crossedTiles = stolenTerritory.concat(crossedTiles);
                    square.piece.belongsTo.defeated = true;
                    stolenTerritory.forEach((square) => {
                        square.setAttribute('class', `${tile.className}`);
                    })
                    stolenTerritory.filter((tile) => {
                        return tile.piece && tile.piece.belongsTo === square.piece.belongsTo;
                    }).forEach((tile) => {
                        captureCount ++;
                        piecesRemoved.push(tile.piece);
                        if (!bot) {
                            let ctx = tile.getContext('2d');
                            ctx.clearRect(0, 0, 300, 150);
                            chessPieces.splice(chessPieces.indexOf(tile.piece), 1);
                            delete tile.piece;
                        }
                    })
                } else {
                    captureCount ++;
                    if (square.piece.belongsTo != players.find((player) => {
                        return player.turn === true;
                    })) {
                        piecesRemoved.push(square.piece);
                    }
                    if (!bot) {
                        let ctx = square.getContext("2d");
                        ctx.clearRect(0, 0, 300, 150);
                        let player = square.piece.belongsTo;
                        chessPieces.splice(chessPieces.indexOf(square.piece), 1);
                        delete square.piece;
                        checkLivingPieces(player);
                    }
                }
            }
        }

        function findPotentialInnerArea(tile) {
            crossedTiles.forEach((square) => {
                square.className = tile.className;
            });
            findEnclosedTiles(tile);
            crossedTiles.forEach((square) => {
                square.className = `${square.lastColor}Tile`;
            })
        }

        function noRepeatingNumbers(tile, index, array) {
            return (array.slice(index + 1)).find((newTile) => {
                return Number(newTile.slice(1, 3)) === Number(tile.slice(1, 3));
            }) ? false : true;
        }

        function noRepeatingLetters(tile, index, array) {
            return (array.slice(index + 1)).find((newTile) => {
                return newTile[0] === tile[0];
            }) ? false : true;
        }

        function toIds(tile) {
            return tile.id;
        }

        function backToElements(tile) {
            return document.getElementById(tile);
        }

        function touches(tile, tileType, direction, enclosedness) {
            let tileLetter = letters[letters.indexOf(tile.id[0])];
            let tileNumber = Number(tile.id.slice(1, 3));
            let touchingTiles = {
                'aboveTile' : document.getElementById(`${letters[letters.indexOf(tileLetter) - 1]}${tileNumber}`), 
                'belowTile' : document.getElementById(`${letters[letters.indexOf(tileLetter) + 1]}${tileNumber}`),
                'leftTile' : document.getElementById(`${tileLetter}${tileNumber - 1}`),
                'rightTile' : document.getElementById(`${tileLetter}${tileNumber + 1}`)
            };
            let trueCount = 0;
            if (isNaN(Number(direction))) {
                if (tileType && !tileType.includes('non')) {
                    return (touchingTiles[direction]).className === tileType
                } else if (tileType) {
                    return (touchingTiles[direction]).className != tileType.slice(3)
                } else {
                    for (let tiles of Object.values(touchingTiles)) {
                        !tiles ? trueCount ++ : trueCount += 0;
                    }
                    return (touchingTiles[direction]) === tileType && trueCount < 2;
                }
            } else if (!enclosedness && direction != 'knight') {
                for (let tiles of Object.values(touchingTiles)) {
                    if (tileType && !tileType.includes('non') && tiles) {
                        tiles.className === tileType ? trueCount ++ : trueCount += 0;
                    } else if (tiles && tileType) {
                        tiles.className != tileType.slice(3) ? trueCount ++ : trueCount += 0;
                    } else {
                        tiles === tileType ? trueCount ++ : trueCount += 0;
                    }
                }
                return trueCount === direction;
            } else if (tileType === 'knight') {
                for (let tiles of Object.values(touchingTiles).concat(getCorners(tiles))) {
                    if (tiles.piece.type === 'knight') {
                        trueCount ++;
                    }
                }
                return trueCount >= direction;
                } else {
                for (let tiles of Object.values(touchingTiles)) {
                    if (tiles && !innerArea.includes(tiles) && tiles.className != tileType) {
                        trueCount ++;
                    }
                }
                return trueCount >= direction;
            }
        }

        function getCorners(tile) {
            let corners = [];
            let tileLetter = tile.id[0];
            let tileNumer = Number(tile.id.slice(1, 3));
            for (let i = 0; i < 4; i ++) {
                let corner = document.getElementById(`${letters[operate(tileLetter, i)]}${operate(tileNumber, i)}`);
                if (corner) {
                    corners.push(corner);
                }
            }
            return corners;
        }

        function operate(idPart, i) {
            if (isNaN(idPart)) {
                idPart = letters.indexOf(idPart);
                return i < 3 ? idPart + 1 : idPart - 1;
            } else {
                return i > 1 ? idPart - 1 : idPart + 1;
            }
        }

        function topToBottom(a, b) {
            return a.id[0] > b.id[0] ? 1 : -1;
        }

        function leftToRight(a, b) {
            return Number(a.id.slice(1,3)) - Number(b.id.slice(1, 3));
        }

        let turnFrozen;

        function toggleTurns() {
            let toggleButton = document.getElementById('toggle');
            turnToggle === 'on' ? turnToggle = 'off' : turnToggle = 'on';
            if (turnToggle === 'on') {
                turnFrozen = turnCount;
                toggleButton.innerHTML = "Turns: Off"
                toggleButton.setAttribute('style', 'margin: 0.5% 47.5%; width: 100px; color: red; font-weight: bold');
            } else {
                turnCount = turnFrozen;
                toggleButton.innerHTML = "Turns: On"
                toggleButton.setAttribute("style", "margin: 0.5% 47.5%; width: 100px; color: green; font-weight: bold");
            }
        }

        function logMove() {
            let movementLog = document.getElementById('movementLog');
            log = '';
            for (let move of movements) {
                log += `${move}\n`;
            }
            if (visibilityToggle === 'off') {
                movementLog.innerHTML = log;
            }
        }

        let visibilityToggle = 'on'

        function makeVisible() {
            let movementLog = document.getElementById('movementLog');
            visibilityToggle === 'on' ? visibilityToggle = 'off' : visibilityToggle = 'on';
            if (visibilityToggle === 'off') {
                movementLog.setAttribute("style", "visibility: visible")
                log != '' ? movementLog.innerHTML = log : movementLog.innerHTML = 'No Moves to Report!';
             } else {
                movementLog.setAttribute("style", "visibility: hidden");
                movementLog.innerHTML = '';
             }
        }

        function turnProgress(piece, tile) {
            turn ++;
            let lastPlayer = players.find((thePlayer) => {
                return thePlayer.turn === true;
            });
            lastPlayer.turn = false;
            let nextPlayer = players.find((player, index, array) => {
                return !player.defeated && isGreaterThan(index, array.indexOf(lastPlayer), array);
            })
            nextPlayer.turn = true;
            if (nextPlayer === lastPlayer) {
                displayWinningScreen(nextPlayer);
                return;
            }
            let turnCounter = document.getElementById("turnCount");
            turnCounter.innerHTML = `Turn: ${Math.ceil((turn - 1) / 4)}`;
            let player = document.getElementById('turns');
            let rightfulColor = nextPlayer.color;
            player.childNodes[0].nodeValue = `${rightfulColor[0].toUpperCase().concat(rightfulColor.slice(1, rightfulColor.length))} Player's Turn!`;
            player.setAttribute("style", `color: ${rightfulColor.toLowerCase()}`);
            if (piece != 'knight') {
                movements.push(`${piece.color[0].toUpperCase()}${piece.color.slice(1, piece.color.length)} ${piece.type}: ${selected.tile.id} to ${tile.id}${captureCount > 0 ? '!' : ''}`);
            } else {
                movements.push(`${tile.className[0].toUpperCase()}${tile.className.slice(1, tile.className.indexOf('T'))} knight: ${crossedTiles[0].id} to ${tile.id}${captureCount > 0 ? '!' : ''}`);
            }
            if (movements.length > 32) {
                movements.shift();
            }
            captureCount = 0;
            logMove();
        }

        function isGreaterThan(num1, num2, array) {
            let livingPlayers = players.filter((player) => {
                return !player.defeated;
            })
            return num1 === 0 && num2 === array.indexOf(livingPlayers[livingPlayers.length - 1]) ? true : num1 > num2;
        }

        function checkLivingPieces(player) {
            let pieces = chessPieces.filter((piece) => {
                return piece.belongsTo === player;
            });
            if (pieces.length === 1) {
                let playerTiles = Array.from(document.getElementsByClassName(`${player.color}Tile`));
                playerTiles.forEach((tile) => {
                    tile.setAttribute('class', `${tile.firstColor}Tile`);
                    if (tile.piece && tile.piece.type  === 'king') {
                        let ctx = tile.getContext('2d');
                        ctx.clearRect(0, 0, 300, 150);
                        chessPieces.splice(chessPieces.indexOf(tile.piece), 1);
                        delete tile.piece;
                    }
                })
                player.defeated = true;
            }
        }

        function bishopContinuityTest(bishopTile) {
            /*
            let corners = getCorners(bishopTile);
            let trueTiles = corners.map((corner) => {
                return corner.className === bishopTile.className;
            });*/
       }

        function displayWinningScreen(player) {
            let currentPlayer = document.getElementById('turns');
            currentPlayer.innerHTML = `${player.color[0].toUpperCase()}${player.color.slice(1, player.color.length)} Player Wins!`;
            allTiles.forEach((tile) => {
                tile.removeEventListener('click', click);
            });
        }

        function start() {
            // makes everything work
        }

    </script>
</body>
</html> 